# Low Layer Refactor Plan (Trend / Snapshot / Symptom / Table)

Canonical scope: `engine/src/low/`
Date: 2025-09-13
Generated by BIS Agent — method splitting roadmap focusing on testability & coverage lift.

## 1. Objectives
- Reduce monolithic method size (complexity, cognitive load)
- Isolate side-effect boundaries (DB, filesystem, logging) for deterministic unit tests
- Increase line coverage in currently low-covered modules (see coverage report: `trend.py` 33%, `snapshot.py` 32%, `symptom.py` 46%, `table.py` 37%)
- Establish consistent extraction pattern previously applied to `TAction.execute_sql`

## 2. General Extraction Pattern
| Pattern | Before | After | Test Focus |
|---------|--------|-------|------------|
| Orchestrators | Single large `execute_sql` | Thin orchestrator + `_phase_` helpers | Phase branch success/fail sequencing |
| Mixed concerns | Existence check + creation | `_check_exists`, `_create_resource` | Return bool decisions |
| Embedded SQL assembly | Inline f-string composition | `_build_<purpose>_sql` | Pure string equality |
| Side-effects (file/DB) | Interleaved logic | `_run_<action>` wrappers | Mock DB/file ops, assert call order |
| Reusable validation | Repeated inline checks | `_validate_<thing>` | Edge case matrix |

## 3. Class Analyses & Proposed Splits
### 3.1 TTrend (`trend.py`)
Existing helpers already define phases; further decomposition targets test granularity.

| Area | Current Method | Lines (approx) | Issue | Proposed Helpers |
|------|----------------|----------------|-------|------------------|
| Init complexity | `__init__` | ~70-140 | Mixed config parsing, path setup, timestamp generation | `_parse_config`, `_init_paths`, `_compute_backup_name`, `_init_world_ref` (private; orchestrated by `__init__`) |
| Existence + creation | `_initialize_trend_data` | 500-560 (file slice) | Existence detection + creation path mingled | `_trend_exists(db_file)`, `_create_initial_trend(db_file)` |
| Schema evolution + append | `_append_new_data` | 560-620 | Column diff + type lookup + alteration + data insert | `_diff_columns(db_file)`, `_add_missing_columns(db_file, new_cols)`, `_insert_new_rows(db_file)` |
| Deduplication assembly | `_finalize_trend_data` | 620-660 | Dedup SQL build + execution | `_build_dedup_sql()`, `_execute_dedup(db_file, sql)` |
| View creation | `_create_trend_view` | 660-710 | Filter clause formation + execution + dependency update | `_build_view_sql()`, `_apply_view(db_file, sql)`, `_update_dependencies()` |
| Cleanup/UI | `_update_ui_and_cleanup` | 710-760 | UI update & temp table drop mixed | `_update_ui()`, `_cleanup_temp_tables(db_file)` |

Risk: Low (pure extractions). Sequence: existence split → append split → dedup/view splits → init factoring (optional later unless needed for coverage).

### 3.2 TSnapshot (`snapshot.py`)
`execute_sql` monolithic multi-step; `validate_schema` couples retrieval + validation.

| Area | Current | Issue | Helpers |
|------|---------|-------|---------|
| Orchestrator | `execute_sql` | Repetitive guard/prepare/exec blocks | `_preflight_checks()`, `_prepare_table()`, `_execute_table()`, `_validate_snapshot_schema()`, `_process_trend()`, `_update_dependencies()` |
| Schema validation | `validate_schema` | Fetch + expectation + comparison interleaved | `_fetch_schema_info()`, `_missing_columns(found)`, `_validate_types(found)` |

Risk: Medium (trend call side-effects). Mitigation: tests stub trend.execute_sql.

### 3.3 TSymptom (`symptom.py`)
Simpler; fast win.

| Area | Current | Issue | Helpers |
|------|---------|-------|---------|
| Orchestrator | `execute_sql` | Mixed preconditions + exec + dependency update | `_preflight()`, `_prepare_table()`, `_execute_table()`, `_update_dependencies()` |

Risk: Very Low.

### 3.4 TTable (`table.py`)
Highest payoff; `prepare_sql` long multi-stage pipeline; existing execution phases map well to extraction.

| Stage | Current Block (prepare_sql) | Proposed Helper | Return |
|-------|-----------------------------|-----------------|--------|
| Schema ensure | Stage 0 | `_ensure_target_schema()` | bool |
| Source presence validation | Stage 1 | `_has_any_sql_source()` | bool |
| SQL reference | Stage 2 | `_load_sql_reference()` | (sql, comment) |
| Direct SQL | Stage 3 | `_load_direct_sql()` | sql |
| Union build | Stage 4 | `_build_union_sql()` | sql |
| Template render | Stage 5 | `_render_template_sql()` | sql |
| File load | Stage 6 | `_load_sql_file()` | sql |
| Param replace | Stage 7 | `_apply_sql_replacements(sql)` | sql |
| Dependency extraction | Stage 8 | `_extract_dependencies(sql)` | list |

`execute_sql` parallels `TAction` pattern:
- `_init_environment()` (existing `_initialize_execution_environment` rename optional) 
- `_acquire_and_materialize()` (wraps routing + pipeline) 
- `_distribute_files()` (current `_handle_file_operations`) 
- `_integrate_database()` (current `_create_database_view`) 
- `_notify_ui()` (current `_update_user_interface`)

Further decomposition:
- Python source path: `_build_python_params()`, `_register_intermediate(result)` (optional later).
- Template: split into `_retrieve_template_code()` and `_render_template(code, params)`.

Risk: Medium-High (largest surface). Strategy: incremental—extract pure read-only stages first (reference, direct sql, union, template retrieval) leaving orchestration unchanged; run tests after each sub-phase.

## 4. Phase Plan & Prioritization
Priority criteria: (1) Low risk, (2) Coverage gains, (3) Test isolation value.

| Phase | Scope | Files | Rationale | Est. Risk | Coverage Impact |
|-------|-------|-------|-----------|-----------|-----------------|
| 1 | TSymptom execute split | `symptom.py` | Trivial, baseline pattern | Very Low | Small +1-2% file |
| 2 | TSnapshot execute split + schema fetch helper | `snapshot.py` | Reuses pattern, unlocks unit tests per step | Low | Moderate |
| 3 | TTrend append & finalize decomposition | `trend.py` | Column diff & dedup SQL pure testable | Low | Moderate |
| 4 | TTable prepare_sql early pure stages (reference/direct/union extraction helpers) | `table.py` | High line count, pure string logic | Med | High |
| 5 | TTable template/file/replacement helpers | `table.py` | More branches; after earlier safety | Med | High |
| 6 | TTrend init & view creation splits | `trend.py` | Less payoff; deferred | Low | Small |
| 7 | Deeper TTable execute_sql phase wrappers | `table.py` | Wider side-effects; last | Med-High | Incremental |

Gate: After Phase 3 re-evaluate coverage; bump threshold to 26 when ≥26.8%.

## 5. Testing Strategy
Focus: pure helpers → isolated unit tests under `engine/test/test_low/` mirroring `test_action_internal` naming.

| Helper Category | Test Type | Key Cases |
|-----------------|-----------|-----------|
| Existence checks (`_trend_exists`) | Pure | Table present / file present / none present |
| Column diff (`_diff_columns`) | Mock DB returns column lists | 0 new cols / multiple new cols |
| Dedup SQL builder (`_build_dedup_sql`) | Pure string | unique_cols empty vs non-empty order correctness |
| View SQL builder (`_build_view_sql`) | Pure | filter present / absent |
| Snapshot preflight | Logical | inactive snapshot / missing table / inactive table |
| Snapshot schema fetch | Mock DB rows | Missing required column / type mismatch warning path |
| Symptom preflight | Logical | no table, inactive symptom/table |
| TTable reference loader | Mapping mocks | Not found vs found with comments |
| Union SQL builder | Provide union config | All tables valid / some skipped / none valid |
| Template retrieval | File vs config fallback | Missing template code returns error comment |
| Replacement application | Parameter absent/present warnings | Parameter mismatch path |

Mocking Approach:
- Provide lightweight FakeDB object with .sql/.execute capturing executed SQL strings.
- Patch minimal attributes (e.g., `world.DB`, `parent.spec_path`).
- For file operations, use temp directories (pytest `tmp_path`).

## 6. Naming & Conventions
- All new helpers prefixed with single underscore.
- Pure helpers return explicit values (no internal logging except debug).
- Orchestrators keep existing log message text to avoid brittle log tests.
- Add docstring one-liners for each new helper.

## 7. Incremental Safety Checklist
- After each phase: run subset tests (affected file internal tests), then full suite.
- Avoid changing existing external method signatures.
- Keep ordering & content of log INFO/WARNING/ERROR lines unchanged.
- Coverage threshold bump only when slack ≥ 0.8%.

## 8. Refactor Backlog (Track)
```yaml
low_refactor_backlog:
  phase_1:
    - file: symptom.py
      tasks: [split_execute, add_internal_tests]
  phase_2:
    - file: snapshot.py
      tasks: [split_execute, split_validate_schema_fetch]
  phase_3:
    - file: trend.py
      tasks: [split_append_new_data, split_finalize_trend]
  phase_4:
    - file: table.py
      tasks: [extract_prepare_stages_0_4]
  phase_5:
    - file: table.py
      tasks: [extract_prepare_stages_5_8]
  phase_6:
    - file: trend.py
      tasks: [split_initialize, split_view_creation]
  phase_7:
    - file: table.py
      tasks: [wrap_execute_pipeline_phases]
```

## 9. Metrics & Success Criteria
| Metric | Baseline | Target (post phases 1-5) |
|--------|----------|--------------------------|
| Overall coverage | 25.85% | ≥26.8% |
| `table.py` coverage | 37% | +5–8% |
| `trend.py` coverage | 33% | +4–6% |
| `snapshot.py` coverage | 32% | +4% |
| `symptom.py` coverage | 46% | ≥55% |
| Avg. execute method length | (varies) | < 25 logical lines each |

## 10. Risks & Mitigations
| Risk | Mitigation |
|------|------------|
| Hidden coupling inside large methods | Extract smallest pure blocks first, retain orchestrator flow |
| Test brittleness due to log text | Do not alter existing log message strings |
| Mock drift for DB API (.sql vs .execute) | Provide dual-method FakeDB ensuring both paths captured |
| Incremental merge conflicts | Isolate phases by file; commit after each phase passes suite |

## 11. Next Immediate Action
Proceed with Phase 1: split `TSymptom.execute_sql` into `_preflight`, `_prepare_table`, `_execute_table`, `_update_dependencies` and add `test_symptom_internal.py`.

---
Generated automatically; adjust backlog entries as phases complete.
